# Лабораторна робота 1
## Виконав: Баланик Богдан (Група ІР-25)
### Рівень 3. Варіант 1

Потрібно написати програму для обходу двовимірного масиву розміром NxM у форматі "зігзагу". Зігзаговий обхід означає, що спочатку ми рухаємось по діагоналях масиву, пчинаючи з лівої верхньої точки.  Другим елементом буде виведено елемент, який знаходиться справа, потім  знизу і ліворуч, далі ще крок вниз і рухаємось по діагоналі знову вправо. Для масиву розміром 3x3 обхід у форматі зігзагу виглядає так (де номер у клітинці відповідає порядку її відвідин):

<pre>
1 2 6
3 5 7
4 8 9
</pre>
Для масиву 3 х 5 це матиме вигляд:
<pre>
1  2  6   7  12
3  5  8  11  13
4  9  10 14 15
</pre>
Реалізуйте алгоритм, який отримає на вхід масив розміром m та n та поверне одномірний масив з значеннями елементів вхідного масиву при обході його у порядку, зазначеному вище у задачі

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` . Ваш тести мають перевірити роботу алгоритму при значеннях m == n == 5, m =2, n =4, n = 1, m = 6, n == m == 1

# Лабораторна робота 2
### Рівень 1. Варіант 1

# Лабораторна робота 3
### Рівень 1. Варіант 1
Існує три найпоширеніші способи проходження бінарних дерев вглиб: **прямий (pre-order), зворотній (post-order) та серединний (in-order)**.

Реалізуйте функцію, яка отримує на вхід вершину бінарного дерева та виконує його зворотній обхід (pre-order traversal) та повертає значення вузлів у списку у відповідному порядку.

Розглянемо таке бінарне дерево:

```
    1
   / \
  2    3
   \  / \
   5  6  7
```
Під час прямого обходу це дерево буде відвідане в такому порядку: `[1, 2, 5, 3, 6, 7]`

Функція `pre_order_traversal(root: BinaryTree) -> List` отримує на вхід корінь бінарного дерева, який має наступний вигляд:
```
class BinaryTree:
    def __init__(self, value, left=None, right=None, parent=None):
        self.value = value
        self.left = left
        self.right = right
```

Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу `BinaryTree` наступним чином:

```
root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)

# Лабораторна робота 3
## Виконав: Баланик Богдан (Група ІР-25)
### Рівень 1. Варіант 1


Для всіх задач слід написати тести з використанням бібліотеки `unittest`.  Ваш проект має бути розділено на окремі папки для коду додатку та тестів (`src` та `test` відповідно).

При написанні коду дотримуйтесь стандарту PEP 8, який визначає правила форматування Python-коду, такі як відступи, довжина рядків, іменування змінних тощо. Для полегшення читабельності коду слід відформатувати ваш код з допомогою  `Black` 

## Рівень 1
### Варіант 1
Існує три найпоширеніші способи проходження бінарних дерев вглиб: **прямий (pre-order), зворотній (post-order) та серединний (in-order)**.

Реалізуйте функцію, яка отримує на вхід вершину бінарного дерева та виконує його зворотній обхід (pre-order traversal) та повертає значення вузлів у списку у відповідному порядку.

Розглянемо таке бінарне дерево:

```
    1
   / \
  2    3
   \  / \
   5  6  7
```
Під час прямого обходу це дерево буде відвідане в такому порядку: `[1, 2, 5, 3, 6, 7]`

Функція `pre_order_traversal(root: BinaryTree) -> List` отримує на вхід корінь бінарного дерева, який має наступний вигляд:
```
class BinaryTree:
    def __init__(self, value, left=None, right=None, parent=None):
        self.value = value
        self.left = left
        self.right = right
```

Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу `BinaryTree` наступним чином:

```
root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)
```